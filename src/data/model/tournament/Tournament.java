package data.model.tournament;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import data.model.schedule.CombinedSchedule;
import data.model.schedule.EventSchedule;
import data.model.schedule.data.Match;
import data.model.tournament.event.Event;
import data.model.tournament.event.entity.Localization;
import data.model.tournament.event.entity.Player;
import data.model.tournament.event.entity.timeslot.Timeslot;
import solver.TournamentSolver;

public class Tournament {
	/**
	 * Nombre del torneo
	 */
	private String name;
	
	/**
	 * Categorías que componen el torneo 
	 */
	private List<Event> events;
	
	/**
	 * Todos los jugadores que participan en el torneo. No se repiten los presentes en múltiples categorías
	 */
	private List<Player> allPlayers;
	
	/**
	 * Todos los terrenos de juego en los que se desarrolla en el torneo. No se repiten los presentes en múltiples categorías
	 */
	private List<Localization> allLocalizations;
	
	/**
	 * Todos los timeslots en los que discurre el torneo. No se repiten los presentes en múltiples categorías
	 */
	private List<Timeslot> allTimeslots;

	/**
	 * Horarios para cada categoría
	 */
	private List<EventSchedule> currentSchedules;
	
	/**
	 * Horario del torneo que combina los horarios de todas las categorías en uno solo
	 */
	private CombinedSchedule schedule;
	
	/**
	 * El solver que obtendrá los horarios de cada categoría el torneo
	 */
	private TournamentSolver solver;
	
	/**
	 * Construye del torneo
	 * 
	 * @param name       nombre del torneo
	 * @param categories categorías que componen el torneo
	 */
	public Tournament(String name, List<Event> categories) {
		this.name = name;
		events = categories;
		
		allPlayers = new ArrayList<Player>();
		for (Event event : events)
			for (Player player : event.getPlayers())
				if (!allPlayers.contains(player))
					allPlayers.add(player);
		

		allTimeslots = new ArrayList<Timeslot>();
		for (Event event : events)
			for (Timeslot timeslot : event.getTimeslots())
				if (!allTimeslots.contains(timeslot))
					allTimeslots.add(timeslot);
		
		allLocalizations = new ArrayList<Localization>();
		for (Event event : events)
			for (Localization localization : event.getLocalizations())
				if (!allLocalizations.contains(localization))
					allLocalizations.add(localization);
		
		solver = new TournamentSolver(this);
	}
	
	/**
	 * Construye un torneo
	 * @param name       nombre
	 * @param categories categorías que componen el torneo
	 */
	public Tournament(String name, Event... categories) {
		this(name, new ArrayList<Event>(Arrays.asList(categories)));
	}
	
	/**
	 * Comienza el proceso de resolución para calcular un primer horario
	 * 
	 * @return true si se ha encontrado una solución, false si ocurre lo contrario
	 */
	public boolean solve() {
		boolean solved = solver.execute();
		
		currentSchedules = solver.getSchedules();
		schedule = null;
		
		return solved;
	}
	
	public void setName(String name) {
		this.name = name;
	}
	
	public String getName() {
		return name;
	}
	
	public List<Event> getEvents() {
		return events;
	}
	
	public List<Player> getAllPlayers() {
		return allPlayers;
	}

	public List<Timeslot> getAllTimeslots() {
		return allTimeslots;
	}
	
	public List<Localization> getAllLocalizations() {
		return allLocalizations;
	}
	
	/**
	 * Agrupa en un diccionario las categorías del torneo por el número de jugadores por partido
	 * 
	 * @return un diccionario donde la clave es el número de jugadores por partido y el valor, la lista
	 * de categorías que definen dicho número de jugadores por partido
	 */
	public Map<Integer, List<Event>> groupEventsByNumberOfPlayersPerMatch() {
		Map<Integer, List<Event>> eventsByNumberOfPlayersPerMatch = new HashMap<Integer, List<Event>>();
		
		for (Event event : events) {
			int n = event.getPlayersPerMatch();
			if (eventsByNumberOfPlayersPerMatch.containsKey(n))
				eventsByNumberOfPlayersPerMatch.get(n).add(event);
			else
				eventsByNumberOfPlayersPerMatch.put(n, new ArrayList<Event>(Arrays.asList(new Event[]{ event })));
		}
		
		return eventsByNumberOfPlayersPerMatch;
	}
	
	/**
	 * Actualiza el valor de los horarios con la nueva solución combinada. Si se ha llegado
	 * a la última solución se establece el valor de los horarios a null. Además, se resetea el valor
	 * del horario combinado
	 * 
	 * @return true si se han actualizado los horarios con una nueva solución, y false si
	 * se ha alcanzado la última solución
	 */
	public boolean nextSchedules() {
		currentSchedules = solver.getSchedules();
		schedule = null;
		return currentSchedules != null;
	}
	
	/**
	 * Devuelve los horarios de cada categoría con el valor actual. Si no se ha actualizado el valor llamando
	 * al método nextSchedules o si el solver ha alcanzado la última solución y se ha llamado seguidamente a
	 * nextSchedules, devuelve null
	 * 
	 * @return los horarios de cada categoría
	 */
	public List<EventSchedule> getSchedules() {
		return currentSchedules;
	}
	
	/**
	 * Devuelve un único horario combinado del torneo que include todos los jugadores, todas las localizaciones de
	 * juego y todas las horas o timeslots de los que compone
	 * 
	 * @return horario combinado del torneo
	 */
	public CombinedSchedule getSchedule() {
		if (schedule == null)
			schedule = new CombinedSchedule(this);
		return schedule;
	}
	
	/**
	 * Añade timeslots no disponibles para el jugador en todas las categorías donde participe
	 * 
	 * @param player
	 * @param timeslots
	 */
	public void addPlayerUnavailableTimeslots(Player player, Set<Timeslot> timeslots) {	
		for (Event event : events)
			if (event.getPlayers().contains(player))
				event.addUnavailablePlayer(player, timeslots);
	}
	
	/**
	 * Añade un timeslot no disponible para el jugador en todas las categorías donde participe
	 * 
	 * @param player
	 * @param timeslot
	 */
	public void addPlayerUnavailableTimeslot(Player player, Timeslot timeslot) {
		for (Event event : events)
			if (event.getPlayers().contains(player))
				event.addUnavailablePlayer(player, timeslot);
	}
	
	/**
	 * Si el jugador no está disponible a la hora timeslot, se elimina de la lista y vuelve a estar disponible a esa hora,
	 * para todas las categorías
	 * 
	 * @param player
	 * @param timeslot
	 */
	public void removePlayerUnavailableTimeslot(Player player, Timeslot timeslot) {
		for (Event event : events)
			if (event.getPlayers().contains(player))
				event.removePlayerUnavailableTimeslot(player, timeslot);
	}
	
	/**
	 * Marca los timeslots de la lista como breaks para todas las categorías
	 * 
	 * @param breakTimeslots
	 */
	public void addBreaks(List<Timeslot> timeslotBreaks) {
		for (Timeslot timeslot : timeslotBreaks)
			for (Event event : events)
				if (event.getTimeslots().contains(timeslot) && !event.isBreak(timeslot))
					event.addBreak(timeslot);
	}
	
	/**
	 * Añade el timeslot como un break para todas las categorías
	 * 
	 * @param timeslotBreak
	 */
	public void addBreak(Timeslot timeslotBreak) {
		for (Event event : events)
			if (event.getTimeslots().contains(timeslotBreak))
				event.addBreak(timeslotBreak);
	}
	
	/**
	 * Elimina el break para todas las categorías
	 * 
	 * @param timeslotBreak
	 */
	public void removeBreak(Timeslot timeslot) {
		for (Event event : events)
			if (event.isBreak(timeslot))
				event.removeBreak(timeslot);
	}
	
	/**
	 * Invalida las pistas del diccionario a las horas indicadas para todas las categorías (si la categoría tiene
	 * esa pista y esos timeslots)
	 * 
	 * @param unavailableLocalizations diccionario de localizaciones de juego descartadas en la lista de timeslots
	 */
	public void setUnavailableLocalizations(HashMap<Localization, List<Timeslot>> unavailableLocalizations) {
		Set<Localization> localizations = unavailableLocalizations.keySet();	
		for (Event event : events)
			for (Localization localization : localizations)
				if (event.getLocalizations().contains(localization)) {
					List<Timeslot> timeslots = unavailableLocalizations.get(localization);
					for (Timeslot timeslot : timeslots)
						if (event.getTimeslots().contains(timeslot))
							event.addUnavailableLocalization(localization, timeslot);
				}
	}
	
	/**
	 * Invalida una pista a una hora o timeslot para todas las categorías (si la categoría tiene dicha pista
	 * y dicha hora)
	 * 
	 * @param localization localización de juego a invalidar
	 * @param timeslot     hora a la que invalidar
	 */
	public void addUnavailableLocalization(Localization localization, Timeslot timeslot) {
		for (Event event : events)
			if (event.getLocalizations().contains(localization) && event.getTimeslots().contains(timeslot))
				event.addUnavailableLocalization(localization, timeslot);
	}
	
	/**
	 * Añade una pista no disponible a las horas indicadas para todas las categorías
	 * 
	 * @param localization
	 * @param timeslots
	 */
	public void addUnavailableLocalization(Localization localization, List<Timeslot> timeslots) {
		for (Event event : events)
			for (Timeslot timeslot : timeslots)
				if (event.getLocalizations().contains(localization) && event.getTimeslots().contains(timeslot))
					event.addUnavailableLocalization(localization, timeslot);
	}
	
	/**
	 * Para cada categoría que contenga la pista, elimina la invalidez de dicha localización
	 * 
	 * @param localization
	 */
	public void removeUnavailableLocalization(Localization localization) {
		for (Event event : events)
			if (event.getLocalizations().contains(localization))
				event.removeUnavailableLocalization(localization);
	}
	
	/**
	 * Para cada categoría que contenga la pista y el timeslot, elimina la invalidez de dicha localización
	 * 
	 * @param localization
	 */
	public void removeUnavailableLocalizationTimeslot(Localization localization, Timeslot timeslot) {
		for (Event event : events)
			if (event.getLocalizations().contains(localization) && event.getTimeslots().contains(timeslot))
				event.removeUnavailableLocalizationTimeslot(localization, timeslot);
	}
	
	/**
	 * Muestra por la salida estándar una representación de los horarios de cada categoría
	 * 
	 * @param printMatches si es true se mostrará un resumen de los partidos por cada categoría, y si es false, no
	 */
	public void printCurrentSchedules(boolean printMatches) {
		StringBuilder sb = new StringBuilder();
		
		if (currentSchedules == null)
			sb.append("Empty schedule.\n");
		else {
			for (EventSchedule schedule : currentSchedules) {
				sb.append(schedule.toString());
				
				sb.append("\n");
				
				if (schedule != null && printMatches) {
					sb.append(String.format("Match duration: %d timelots\n", schedule.getEvent().getMatchDuration()));
					
					schedule.calculateMatches();
					List<Match> matches = schedule.getMatches();
					for (Match match : matches)
						sb.append(match).append("\n");
				}
					
				sb.append("\n");
			}
		}
		
		System.out.println(sb.toString());
	}
	
	/**
	 * Llama a printCurrentSchedules(true), mostrándose por la salida estándar los horarios y los partidos
	 */
	public void printCurrentSchedules() {
		printCurrentSchedules(true);
	}
	
	/**
	 * @return número de partidos que se juegan en el torneo
	 */
	public int getNumberOfMatches() {
		int numberOfMatches = 0;
		for (Event event : events)
			numberOfMatches += event.getNumberOfMatches();
		return numberOfMatches;
	}
	
	public TournamentSolver getSolver() {
		return solver;
	}
	
	public String toString() {
		return name;
	}
}
